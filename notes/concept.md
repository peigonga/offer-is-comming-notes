#### 异或

用^表示，两个操作数对应的二进制位，相同为0不同为1

使用技巧：

- 交换两个整数

  ```java
  if(a != b){
    a ^= b;
    b ^= a;
    a ^= b;
  }
  ```



#### 按位与

用&表示，两个操作数对应的二进制，相同为1，不同为0

使用技巧：

- 判断奇偶

  ```java
  if(a & 1 == 0){
    //偶数
  }else{
    //奇数
  }
  ```



#### 按位或

用|表示，两个操作数对应的二进制位，有1位1，无1为0

#### 取反

用~表示，二进制位中0变1，1变0

用法

- 变换符号

  ```java
  public int signReversal(int a){
    return ~a + 1;
  }
  ```

- 配合右移求绝对值

  ```java
  public int abs(int a){
    int i = a >> 31;
    return i == 0 ? a : (~a + 1)
  }
  
  public int abs(int a){
    int i = a >> 31;
    //对于任何数，与0异或都会保持不变
    return ((a ^ i) - i);
  }
  ```



#### Java程序的运行过程

- 编译器将Java源文件编译成相应的字节码文件
- JVM将字节码文件翻译成相应操作系统的机器码
- 机器码调用相应操作系统的本地方法库执行相关指令操作

#### JVM的组成

由类加载器子系统、运行时数据区、执行引擎和本地接口库组成

- 类加载器子系统将编译好的字节码文件加载到JVM中
- 运行时数据区用于存储JVM运行过程中产生的数据。由方法区、本地方法区、堆、栈、程序计数器组成
- 执行引擎包括垃圾回收器和即时编译器。垃圾回收器用于回收不再使用的对象，即时编译器作用是将热点代码编译成机器码
- 本地接口库通过调用本地方法库完成具体的指令操作

#### JVM的内存区域

- 线程私有区
  - 程序计数器： 用于存储当前线程执行字节码的行号指示器，即实时虚拟机字节码指令的地址
  - 栈：描述Java方法的执行过程
  - 本地方法区：类似栈，为Native方法服务

- 线程共享区
  - 方法区：存储常量、静态变量、类信息、即时编译器编译后的机器码、运行时常量池等。
  - 堆：存储运行过程中创建的对象和数据，垃圾回收的最主要内存区域

- 直接内存

#### 堆内存分配

JVM的运行时内存也叫做JVM堆，从GC的角度可以将堆分为新生代、老年代、永久代，其中新生代占1/3堆空间，老年代占2/3堆空间，永久代占用很少的空间，且从Java8开始被元数据区取代。新生代又分为一个Eden区和两个Survivor区，默认占比为8:1:1

#### 新生代GC

称作MinorGC，由于新创建的对象存放在新生代，所以新生代会频繁的GC，常用的Java版本的MinorGC使用复制算法：

1. 将Eden和SurvivorFROM中存活的对象复制到SurvivorTo区，如果对象的年龄达到老年代标准，则复制到中止当前复制，直接复制到老年代，否则年龄加一，如果是大对象或SurvivorTo区域空间不足，也直接将对象复制到老年代。
2. 清空Eden和SurvivorFrom区域
3. SurvivorTo和SurvivorFrom区域互换，本次的SurvivorTo称为下次GC的SurvivorFrom

#### 老年代GC

采用标记整理算法，一般由有新对象进度老年代导致老年代空间不足或没有足够大的连续空间分配给大对象时触发。

#### 如何确定对象需要回收

- 引用计数法
- 可达性分析：采用根搜索算法实现，从一系列的GC Roots开始向下搜索，如果一个对象到任意GC Roots之前都没有引用链作用，那么认为这个对象可以被回收

#### Java中的引用类型

- 强引用
- 软引用
- 弱引用
- 虚引用

#### 垃圾回收算法

- 新生代
  - Serial：单线程复制算法
  - ParNew：多线程复制算法
  - Parallel Scavenge：多线程复制算法，更好的利用CPU，吞吐量更高
- 老年代
  - Serial Old：单线程标记整理算法
  - Parallel Old：多线程标记整理算法
  - CMS：多线程标记清除算法
- G1：弱化分代概念的标记整理算法

#### G1

##### 特点

- 并行与并发：充分利用多CPU多核来缩短STW时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1可以通过并行的方式让Java线程继续执行
- 分代收集：
- 空间整合：G1整体看来是基于标记-整理算法，从两个Region之间看来是基于复制算法实现的。
- 可预测的停顿：可预测的建立停顿的时间模型，能让使用者明确指定在一个长度为M的毫秒时间片段内，消耗在垃圾收集上的时间不得超过N毫秒

##### G1的堆内存分配

将整个堆内存分配为多个大小相等的独立区域（Region），虽然保留了新生代和老年代的概念，但他们不再是物理隔离的，都是一部分Region的集合。一般分类2000个左右Region，每个Region范围为1-32MB，一般为4M

##### G1各Region的回收的优先级

G1跟踪各个Region里面的垃圾堆积价值（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。

##### 如何避免全堆扫描

每个Region都有一个RememberedSet，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个WriteBarrier暂时中断操作，检查Reference引用的对象是否处于不同的Region之中，如果是，则通过CardTable把相关引用信息记录到被引用对象所属的Region的RememberedSet中

##### G1大致步骤

- 初始标记：标记GC Roots可直接关联到的对象，需要停顿线程，但耗时很短
- 并发标记：在堆中进行可达性分析，找出存货活对象，耗时较长，与用户程序并行进行
- 最终标记：修正并发标记时因用户程序继续运作而变动的那部分标记记录
- 筛选回收：对各Region的回收价值和成本进行排序

#### 类加载阶段

- 加载：指JVM读取编译好的字节码文件，根据描述创建java.lang.Class对象的过程。
- 验证：确保Class文件符合当前虚拟机要求
- 准备：主要是在方法去中为类变量分配空间并设置初始值
- 解析：将常量池中的符号引用替换为直接饮用
- 初始化：执行类构造器的初始化方法对类进行初始化，该方法由编译器在编译阶段自动收集的静态代码块和变量赋值操作组成

#### 类加载器

Java提供了三种默认的类加载器，分别是启动类加载器、扩展类加载器和应用程序类加载器

#### 类加载机制

Java采用双亲委派机制对类进行加载，当收到一个类的加载请求时，不会立即对类进行加载，而是依次向上委派，直到启动类加载器再开始尝试加载，如果无法加载，则向下一级进行委派，直到加载成功，否则跑出ClassNotFoundException

#### Exception、Error

Exception都继承了Throwable，Java中只有Throwable类型的实例才可以被抛出和捕获

Error是程序运行中不太可能出现的问题，绝大部分的Error会导致程序处于非正常的、不太可能恢复的状态。

Exception是程序正常运行中可预料的意外情况，可能并且应该被捕获，进行相应处理

RuntimeException是通过编码可以避免的逻辑错误，根据实际需要判断是否需要捕获

#### 设计原则

- 单一职责原则：一个类只有一个职责
- 开闭原则：一个对象(类、模块、函数等)对扩展开放，对修改关闭
- 里氏替换原则：规定任意父类可以出现的地方，子类都一定可以出现
- 依赖倒置原则：指称需要依赖于抽象，不依赖于具体实现
- 接口隔离原则：指将不同的功能定义在不同的接口中来实现接口的隔离，这样就
  避免了其他类在依赖该接口时依赖其不需要的功能
- 迪米特法则：指一个对象尽可能少的与其他对象发生相互作用，即一个对象对其他
  对象应该有尽可能少的了解或依赖
- 合成/聚合服用原则：指通过在一个新的对象中引入已有的对象以达到类的功能复用
  和扩展的目的。

#### 设计模式分类

按照功能和使用场景和氛围三大类：创建型(Creational Pattern)、
结构型(Structural Pattern)和行为型(Behavioral Pattern)

- 创建型：是对象创建过程中各类问题的解决方案
  1. 工厂模式(Factory Pattern)
  2. 抽象工厂模式(Abstract Factory Pattern)
  3. 单例模式(Singleton Pattern)
  4. 建造者模式(Builder Pattern)
  5. 原型模式(Prototype Pattern)
- 结构型：针对软件设计结构的总结，关注类、对象之间的组合、继承方式的经验
  1. 适配器模式(Adapter Pattern)
  2. 桥梁模式(Bridge Pattern)
  3. 过滤器模式(Filter Criteria Pattern)
  4. 组合模式(Composite Pattern)
  5. 装饰器模式(Decorator Pattern)
  6. 外观模式(Facade Pattern)
  7. 享元模式(Flyweight Pattern)
  8. 代理模式(Proxy Pattern)
- 行为型：从类或对象之间交互、职责划分角度总结的经验
  1. 责任链模式(Chain Of Responsibility Pattern)
  2. 命令模式(Command Pattern)
  3. 解释器模式(Interpreter Pattern)
  4. 迭代器模式(Iterator Pattern)
  5. 中介者模式(Mediator Pattern)
  6. 备忘录模式(Memento Pattern)
  7. 观察者模式(Observer Pattern)
  8. 状态模式(State Pattern)
  9. 策略模式(Strategy Pattern)
  10. 模板模式(Template Pattern)
  11. 访问者模式(Visitor Pattern)

#### 接口和抽象类的区别

- 接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口不可实例化，不能含有任何非静态成员，任何属性都隐含public static final意义，没有任何非静态方法实现
- 抽象类是不可实例化的类，用abstract关键字修饰class，其主要目的是代码重用。

#### 进程

进程是计算机的程序关于某一数据集合上的一次活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础

#### 线程

线程是操作系统能够进行运算调度的最小单位

#### 进程和线程的区别

- 进程是运行中的程序，线程是进程内部的一个执行序列
- 进程是资源分配的单元，线程是执行单元
- 进程间切换代价大，线程间切换代价小
- 进程拥有资源多，线程拥有资源少
- 多个线程共享进程的资源

#### 事务的特性

- 原子性：一个事务中的操作要么全都成功，要么全都失败
- 一致性：事务提交前后，数据的完整性保持一致
- 隔离性：多个事务之间的操作互不影响
- 持久性：事务提交后对数据的改动是持久的

#### MySQL数据库隔离级别

- 未提交读：可以读到其他事务未提交的改动，会有脏读、幻读、不可重复读
- 已提交读：只能读到其他事务已经提交的改动，会有幻读、不可重复读
- 可重复读：MySQL默认的隔离级别，会有幻读，但MySQL通过MVCC解决了这个问题
- 串行读：不会有任何问题，但是吞吐量低

#### 一个线程在线程池中的运行流程是什么样的

1. 如果线程池不是RUNNING状态，直接拒接
2. 如果线程数没有达到corePoolSize，则创建新的线程执行
3. 如果达到了核心线程数且队列未满，则加入队列
4. 如果达到了核心线程数队列满了，也没有达到最大线程数，且队列已满，则创建新的线程执行
5. 如果达到了最大线程数且队列满了，则执行拒绝策略

#### ThreadPoolExecutor参数的含义

- corePoolSize：核心常驻线程数，即使没有任务时，也会保留的线程数
- maximumPoolSize：表示任务最多的时候可创建的最多线程数
- keepAliveTime：表示线程存活时间，当线程池空闲并超过了此时间，多余的线程就会销毁
- unit：存活时间的单位
- workQueue：线程池执行的任务队列，当线程池所有线程都在处理任务时，新进的任务就会进入该队列等待执行
- threadFactory：线程的创建工厂，较少使用
- rejectedExecutionHandler：指定线程池的拒绝策略，指定当线程池的队列满了之后，采用何种方式拒绝新的任务请求

#### 线程池execute和submit的区别

execute没有返回值，submit可以接收返回值

#### 线程池的拒绝策略

- AbortPolicy：终止策略，线程池会抛出异常并终止执行，这是默认的策略
- CallerRunsPolicy：把任务交给当前线程来执行
- DiscardPolicy：忽略此任务
- DiscardOldestPolicy：忽略最早的任务

#### ConcurrentHashMap在1.7和1.8的区别

- 在1.7中基于Segment和HashEntry实现
  - put的时候计算出对应的Segment的位置，如果segment还未初始化，则通过CAS进行初始化，然后通过segment的put方法进行加锁插入
- 在1.8中基于Synchronized+CAS+Node实现
  - 第一次执行put的时候，执行initTable初始化node数组
  - 当put的时候Node还未初始化，则通过CAS插入数据
  - 如果Node不为空且不为移动状态，则通过synchronized加锁进行更新或插入

#### 乐观锁和悲观锁

- 乐观锁：在读取数据的时候不会进行加锁，但在修改数据的时候会判断数据是否被更新。具体流程为比较当前版本号和上一次的版本号，如果版本号一致，则更新，否则重复进行读、比较、写操作。Java中的乐观锁大部分聚义CAS机制实现，该机制是一个原子更新操作
- 悲观锁：在读取的时候会直接进行加锁，其他线程在访问数据时会进入阻塞。Java中的悲观锁大多基于AQS实现。

#### 死锁的四个条件

- 互斥：一个资源同时只能被一个线程使用
- 请求与保持：当请求一个资源被阻塞式，不会释放已获得的资源
- 不剥夺：在使用完资源之前，不会被强制剥夺
- 循环等待：多干线程之间形成一种循环等待的情况

#### OSI 7层模型

- 应用层：为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录等协议
- 表示层：将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。因此它主要负责数据格式的转换。具体来说就是将设备固有的数据格式转换为网络标准传输格式
- 会话层：负责建立和断开通信连接，以及数据的分割等数据传输相关的管理
- 传输层：起着可靠传输的作用。只在通信双方节点上进行处理，无需再路由器上处理
- 网络层：将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择
- 数据链路层：负责物理层面上互连的、节点之间的通信传输。将0和1序列划分为具有意义的数据帧传送给对端，即数据帧的生成与接收
- 物理层：负责0、1比特流与电压的高低、光的闪灭之间的互换

#### TCP/IP 模型

- 应用层：为应用程序提供服务
- 传输层：建立端口到端口的通信。主要功能就是让应用程序之间实现通信。有两个具有代表性的协议：TCP和UDP
  - TCP：面向有连接的传输层协议。可以保证两端通信主机之间的通信可达。
  - UDP：面向无连接的传输层协议。
- 网络层：使用IP协议基于IP地址转发分包数据
- 网络接口层：负责IP数据包的接收与发送

#### TCP三次握手

- 客户端发送SYN，seq=x的报文到服务器，进入SYN_SEND状态
- 服务器收到客户端的SYN报文，回应一个ACK，ack=x+1的报文，同时发送一个SYN，seq=y的报文进入SYN_RECV状态
- 客户端收到服务器的报文回应一个ACK，ack=y+1的报文，进入Established状态，服务器收到客户端的ACK也进入Established状态

#### TCP四次挥手

- 客户端发送一个FIN=1，seq=u的报文，进入FIN-WAIT-1状态
- 服务器收到FIN报文后，回应一个ACK报文，ack=u+1，seq=v，服务器进入CLOSE-WAIT状态，客户端收到ACK报文后，进入FIN-WAIT-2状态
- 服务器数据传送完成后发送一个FIN=1，ACK=1，seq=w，ack=u+1的报文到客户端，进入LAST-ACK状态
- 客户端在收到ACK后，回应一个ACK报文，ack=w+1，seq=u+1，进入TIME-WAIT状态，在等待2MSL时间之后，进入CLOSE状态

#### SpringBean的初始化流程

- 实例化Bean
- 设置属性注入依赖
- 处理Aware相关操作
- 如果实现了InitialiizingBean则执行afterPropertiesSet方法
- BeanPostProcessor前置处理
- 执行init-method
- BeanPostProcessor后置处理

#### Spring初始化流程

主要流程在AbstractApplicationContext的refresh方法里实现

1. 为Context刷新做一些如处理
2. 刷新内部BeanFactory，创建IoC容器，通过配置解析出BeanDefinition
3. 对IoC容器做一些预处理
4. 提供了一个钩子方法允许子类对BeanFactory做后置处理
5. 注册BeanPostProcessor后置处理器
6. 初始化一些消息资源
7. 初始化应用广播事件
8. 有一个onRefresh的钩子方法，用于初始化一些特殊的Bean，比如初始化Web容器
9. 注册一些监听器
10. 实例化Bean

#### Spring如何保证单例bean在多线程下对数据库的操作使用同一个Connection

[待深入了解补充]TransactionSynchronizationManager中使用ThreadLocal实现

#### SpringMVC用到的设计模式

- 责任链
- 组合
- 适配器
- 策略
- 建造者

#### 反射

反射是Java提供的一种基础功能，赋予程序在运行时自省的能力。通过反射可以直接操作类或对象，如获取某个对象的类定义，获取类声明的方法和属性，执行方法或构造对象，甚至可以在运行时修改类定义

#### 动态代理

动态代理是一种方便运行时动态构建代理对象、动态处理代理方法调用的机制。

JDK动态代理是基于反射实现的，cglib是基于字节码机制实现的

- JDK代理：
  - 依赖少，JDK本身支持，相对于cglib更可靠
  - 实现简单
  - 可平滑进行JDK版本升级
- cglib:
  - 不需要被代理对象实现固定的接口，更灵活
  - 性能更好
  - 只关心需要操作的类，不会为其他相关类增加工作量

#### 原始数据类型和包装数据类型的区别

- 包装类型是对象，原始数据类型不是
- 作为参数的传递不一样，包装类型是引用传递，基本类型是值传递
- 声明方式不一样，包装类型需要通过new，基本数据类型不用
- 初始值不一样，包装类型初始值为null，基本类型为0、false或/u0000

#### 索引的作用和优缺点

作用：创建索引能够提高系统性能

优点：

- 通过创建唯一索引，可以保证数据表中每一行数据的唯一性
- 加快数据的检索速度
- 加快表与表之间的连接
- 在使用分组和排序，子句进行数据检索时，可以显著减少查询中分组和排序的时间
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统性能

缺点：

- 创建和维护索引需要时间
- 索引需要占用物理空间
- 数据插入、更新和删除时，索引也要动态维护，会需要时间

#### MySQL全表扫描原因

- 使用左模糊查询
- 使用or
- 使用in或not in条件较多时
- 使用!=
-

#### MySQL 自增主键和UUID的优劣

自增id是有序的，存到磁盘上也是有序的，相比uuid开销更好

uuid占用空间更多

#### MySQL在字段值分布很少的情况下不要加索引

#### 符合索引index(a,b,c)使用情况

MySQL符合索引最左原则

- where a=3  只使用了a

- where a=3 and b=5  使用了a,b

- where a=3 and b=5 and c=4  使用了a,b,c

- where b=3 or where c=4  没有使用索引

- where a=3 and c=4  仅使用了a

- where a=3 and b>10 and c=7  使用了a,b

- where a=3 and b like 'xx%' and c=7  使用了a,b

  其实相当于创建了多个索引：key(a)、key(a,b)、key(a,b,c)

#### MySQL哪些SQL支持事务

- DDL（Data Definition Languages）语句：即数据库定义语句，用来创建数据库中的表、索引、视图、存储过程、触发器等，常用的语句关键字有：CREATE,ALTER,DROP,TRUNCATE,COMMENT,RENAME。
- DML（Data Manipulation Language）语句：即数据操纵语句，用来查询、添加、更新、删除等，常用的语句关键字有：SELECT,INSERT,UPDATE,DELETE,MERGE,CALL,EXPLAIN PLAN,LOCK TABLE,包括通用性的增删改查。
- DCL（Data Control Language）语句：即数据控制语句，用于授权/撤销数据库及其字段的权限（DCL is short name of Data Control Language which includes commands such as GRANT and mostly concerned with rights, permissions and other controls of the database system.）。常用的语句关键字有：GRANT,REVOKE。
- TCL（Transaction Control Language）语句：事务控制语句，用于控制事务，常用的语句关键字有：COMMIT,ROLLBACK,SAVEPOINT,SET TRANSACTION。

#### MyBatis #{} 和#{}的区别

${}是直接字符串替换

#{}是参数的两边会加上''

#### Spring事务

Spring本身并不实现事务，他只是管理事务，事务的实现还是有数据库来进行，Spring管理事务的方式有两种：编程式事务和声明式事务

#### 缓存穿透

指查询一个根本不存在的数据，缓存层和存储层都不会命中。缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。

优化方式有：

- 缓存空对象
- 布隆过滤器拦截

#### 缓存雪崩

缓存雪崩，是指在某一个时间段，缓存集中过期失效。另外，当缓存层不能正常提供服务，所有的请求都会达到存储层，存储层的访问会暴增，很大概率会造成存储层级联宕机的情况。

预防方式有：

- 对于缓存集中过期，可以为缓存的数据做分类，缓存不同的周期，或者在设置过期时间的时候加入一个随机因子
- 保证缓存层的高可用性
- 依赖隔离组件为后端限流并降级

#### 缓存击穿

缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

预防方式：

- 对于热点数据不设置过期时间

#### 缓存污染

指留在缓存中的数据实际上不会再访问了，但是又占据了缓存空间，如果这样的数据比较大，甚至沾满了缓存空间，每次有数据写入缓存时，需要把这类数据逐步淘汰出缓存，会增加缓存操作的时间开销

#### Redis的I/O多路复用实现

- 采用Linux的select/epoll机制实现
- 内核可同时监听多个监听套接字和多个已连接套接字
- 一旦内核监听到套接字上有请求，则通知Redis线程处理数据
- select/epoll提供了基于事件的回调机制，这些事件会放入一个队列中，Redis单线程对该对列不断的进行处理

#### Redis的潜在阻塞点

1. 集合全量查询和聚合操作
2. bigkey删除操作【可异步】
3. 清空数据库【可异步】
4. AOF日志同步写【可异步】
5. 加载RDB文件，主要是从库

#### Redis的淘汰策略

- noevction:不进行淘汰
- 进行淘汰
  - 设置了过期时间的淘汰
    - volatile-lru
    - volatile-lfu
    - volatile-ttl
    - volatile-random
  - 未设置过期时间的淘汰
    - allkeys-lru
    - allkeys-lfu
    - llkeys-random

#### Redis的rdb和AOF的区别

- RDB：某个时间点的Redis内存数据的全量快照

  - 两种方式：save和bgsave，bgsave由主线程fork子进程实现，不会阻塞主线程读，使用CopyOnWrite避免阻塞主线程写

- AOF：保存对Redis的操作命令记录

  - 写后日志，先写内存，再记录日志，可以避免记录错误的命令，但是如果写完内存后宕机，数据会遗失

  - AOF的写入可能会给后续操作带来阻塞

  - AOF的写回策略:

    | 名称     | 写回时机           | 优点                     | 缺点                             |
        | -------- | ------------------ | ------------------------ | -------------------------------- |
    | Always   | 同步写回           | 可靠性高，数据及本不丢失 | 每个写命令都要落盘，性能影响较大 |
    | Everysec | 每秒写回           | 性能适中                 | 宕机时丢失前一秒数据             |
    | No       | 操作系统控制的写回 | 性能好                   | 宕机时丢失数据较多               |

  - AOF的重写机制：由子进程对原有AOF进行多变一，将AOF拷贝一份，在重写完成前，对Redis的操作会同时记录到两个AOF中

#### Redis Sentinal选主规则

- 先筛选符合符合条件的从库，从库在线且网络条件良好
- 依照优先级、复制进度、从库ID号进行打分，分高的为主库

#### Netty的Reactor几种模式

三种

- Reactor单线程模式
- Reactor多线程模式
- Reactor主从多线程模式

#### 粘包的主要原因

- 发送方每次写入数据 < 套接字缓冲区大小
- 接收方读取套接字缓冲区数据不够及时

#### 半包的主要原因

- 发送方写入数据 > 套接字缓冲区大小
- 发送的数据大于协议的MTU(Maximum Transmission Unit，最大传输单元)，必须拆包

#### BASE理论

BASE理论是由CAP中一致性和可用性不可兼得而衍生出来的一种新的思想，BASE理论的核心思想是牺牲一部分数据的强一致性来获得高可用性

- Basically Available（基本可用）：分布式系统出现故障时，允许损失一部分功能的可用性，保证核心功能的可用
- Soft State（柔性状态）：允许系统中的数据存在中间状态，这个状态不影响系统的可用性，也就是允许系统中不同节点的数据副本之间的同步存在延迟
- Eventually Consistent（最终一致性）：中间状态的数据在经过一段时间之后，会达到一个最终的数据一致性

#### Redis Cluster数据分区

Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0~16383整数槽内，计算公式为：slot=CRC(key)&16383。每个节点负责维护一部分槽以及槽所映射的键值数据

#### SpringCloud的理解

SpringCloud并不是一种全新的框架，它是微服务场景下各解决方案基于SpringCloud规范，通过SpringBoot进行的整合，是开发人员可以以一种开箱即用的方式来使用这些框架

#### Dubbo的理解

Dubbo是一个RPC框架，实现系统之间高性能、透明化的调用，与普通RPC框架不同的是，它还提供了服务治理功能，如服务注册、监控、路由、容错等

#### RPC

Remote Process Call，远程过程调用。它是一种通过网络调用远程服务，而不需要关注低层网络技术的思想

#### Dubbo的容错模式有几种

- failover：失败自动切换。当服务调用失败时，会切到集群中的其他机器进行重试，默认次数为2，通过retries设置重试次数。通常用与读模式，因为写模式的重试可能会造成数据重复，另外，重试会导致响应延迟
- failfast：快速失败。当服务调用失败，立即报错，也就是只发起一次请求。通常用于一些幂等的写操作，可避免在结果不确定的情况下导致数据重复插入
- failsafe：失败安全。出现异常时，直接忽略
- failback：失败后自动恢复。服务调用异常时，在后台记录这条失败的请求定时重发。适用于消息通知操作，保证这个请求一定发送成功
- forking：并行调用集群中多个服务，只要一个返回成功就返回，通过forks设置
- broadcast：广播调用所有服务提供者，任意一个失败的表示服务调用失败。通常用于通知所有服务提供者更新缓存或本地资源信息
- available：调用集群中任一可用节点，如果没有则抛出异常
- mergeable：异步调用集群中的各节点，并合并结果集，一般配合group使用

#### Dubbo的负载均衡策略

- Random：随机，可调整服务器的权重值提高随机几率
- RoundRobin：轮询。按照公约后的权重设置轮询比例
- LeastActive：最少活跃数。处理较慢的节点将会受到更少的请求
- ConsistentHash：一致性哈希。相同的参数总是发送到同一个服务提供者
- ShortestResponse：最短响应时间。过滤出响应时间最短的服务提供者，如果有多个，则根据权重进行选择

#### 服务治理相关配置的位置及优先级

配置在@Service和@Reference上，优先级：客户端方法级 -> 客户端接口级 -> 服务端方法级 -> 服务端接口级

#### ZooKeeper的理解

简单地说，ZooKeeper是一种有文档式结构数据存储的分布式协调中间件，通过文档是结构的特点和zk提供的节点的特点以及Watcher机制，可以实现一些分布式场景中的需求，如数据配置中心、分布式锁、Master选举、服务上下线动态感知等

#### ZooKeeper的节点类型

- 持久化节点
- 临时节点：与创建该节点的客户端生命周期一致
- 有序节点：在创建的节点后会增加一个递增的序列，持久化节点和临时节点都可以设置为有序节点
- 容器节点：当容器节点下的最后一个子节点被删除时，容器节点就会被自动删除
- TTL节点：针对持久化节点或持久化有序节点，可以设置一个存活时间，如果在存活时间内没有任何修改也没有任何子节点，他就会被自动删除

#### 服务限流的作用

限流的主要目的是通过限制并发访问数或者一个时间窗口内允许处理的请求数量来保护系统，一旦达到限制数量则对当前请求进行处理采取对应的拒绝策略，比如跳转到错误页面拒绝请求、进入排队系统、降级等。从本质上来说，限流的主要作用是损失一部分用户的可用性，为大部分用户提供稳定可靠的服务。

#### 限流常用算法

- 计数器算法：是一种比较简单的限流实现算法，在指定周期内累加访问次数，当访问次数达到设定的阈值，触发限流策略，当进入下一个时间周期时进行访问次数的清零，但是会存在临界问题，比如阈值为100，前一个时间窗口的后几秒请求为100，后一个时间窗口的前几秒请求数为100，整体看来就会有几秒内的总请求量达到200，超过了阈值
- 滑动窗口算法：为了解决计数器算法带来的临界问题，引入了滑动窗口算法。滑动窗口算法的原理是在一固定窗口中分割出多个小时间窗口，分别在每个小时间窗口中记录访问次数 ，然后根据时间将窗口往前滑动并删除过期的小时间窗口。最终只需要统计滑动窗口范围内的所有小时间窗口总的计数即可。
- 令牌桶限流算法：对于每一个请求，都需要从令牌桶中获得一个令牌，如果没有获得令牌，则需要出发限流策略。系统会以一个恒定的速度往固定容量的令牌桶中放入令牌，如果有客户端请求，则需要先从了令牌桶中拿到令牌以获得访问资格。
- 漏桶限流算法：漏桶限流算法内维护一个容器，这个容器会以恒定的速度出水，不管水桶的注水速度有多快，漏桶出水的速度适中保持不变。消息中间件就使用了漏桶限流的思想。

#### Sentinel的限流有几种方式

- QPS(Queries Per Second)
- 并发线程模式

#### Sentinel的熔断策略有几种

- 秒级RT(Response Time)
- 秒级异常比例
- 分钟级异常数

