#### 原始数据类型和包装数据类型的区别

- 包装类型是对象，原始数据类型不是
- 作为参数的传递不一样，包装类型是引用传递，基本类型是值传递
- 声明方式不一样，包装类型需要通过new，基本数据类型不用
- 初始值不一样，包装类型初始值为null，基本类型为0、false或/u0000

#### 索引的作用和优缺点

作用：创建索引能够提高系统性能

优点：

- 通过创建唯一索引，可以保证数据表中每一行数据的唯一性
- 加快数据的检索速度
- 加快表与表之间的连接
- 在使用分组和排序，子句进行数据检索时，可以显著减少查询中分组和排序的时间
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统性能

缺点：

- 创建和维护索引需要时间
- 索引需要占用物理空间
- 数据插入、更新和删除时，索引也要动态维护，会需要时间

#### MyBatis #{} 和#{}的区别

${}是直接字符串替换

#{}是prepareStatement、字符串的两边会加上''

#### Spring事务

Spring本身并不实现事务，他只是管理事务，事务的实现还是有数据库来进行，Spring管理事务的方式有两种：编程式事务和声明式事务

#### 缓存穿透

指查询一个根本不存在的数据，缓存层和存储层都不会命中。缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。

优化方式有：

- 缓存空对象
- 布隆过滤器拦截

#### 缓存雪崩

 当缓存层不能正常提供服务，所有的请求都会达到存储层，存储层的调用量会暴增，很大概率会造成存储层也会级联宕机的情况。

预防方式有：

- 保证缓存层的高可用性
- 依赖隔离组件为后端限流并降级

#### BASE理论

BASE理论是由CAP中一致性和可用性不可兼得而衍生出来的一种新的思想，BASE理论的核心思想是牺牲一部分数据的强一致性来获得高可用性

- Basically Available（基本可用）：分布式系统出现故障时，允许损失一部分功能的可用性，保证核心功能的可用
- Soft State（柔性状态）：允许系统中的数据存在中间状态，这个状态不影响系统的可用性，也就是允许系统中不同节点的数据副本之间的同步存在延迟
- Eventually Consistent（最终一致性）：中间状态的数据在经过一段时间之后，会达到一个最终的数据一致性

#### Redis Cluster数据分区

Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0~16383整数槽内，计算公式为：slot=CRC(key)&16383。每个节点负责维护一部分槽以及槽所映射的键值数据

#### SpringCloud的理解

SpringCloud并不是一种全新的框架，它是微服务场景下各解决方案基于SpringCloud规范，通过SpringBoot进行的整合，是开发人员可以以一种开箱即用的方式来使用这些框架

#### Dubbo的理解

Dubbo是一个RPC框架，实现系统之间高性能、透明化的调用，与普通RPC框架不同的是，它还提供了服务治理功能，如服务注册、监控、路由、容错等

#### RPC

Remote Process Call，远程过程调用。它是一种通过网络调用远程服务，而不需要关注低层网络技术的思想

#### Dubbo的容错模式有几种

- failover：失败自动切换。当服务调用失败时，会切到集群中的其他机器进行重试，默认次数为2，通过retries设置重试次数。通常用与读模式，因为写模式的重试可能会造成数据重复，另外，重试会导致响应延迟
- failfast：快速失败。当服务调用失败，立即报错，也就是只发起一次请求。通常用于一些幂等的写操作，可避免在结果不确定的情况下导致数据重复插入
- failsafe：失败安全。出现异常时，直接忽略
- failback：失败后自动恢复。服务调用异常时，在后台记录这条失败的请求定时重发。适用于消息通知操作，保证这个请求一定发送成功
- forking：并行调用集群中多个服务，只要一个返回成功就返回，通过forks设置
- broadcast：广播调用所有服务提供者，任意一个失败的表示服务调用失败。通常用于通知所有服务提供者更新缓存或本地资源信息

#### Dubbo的负载均衡策略

- Random：随机，可调整服务器的权重值提高随机几率
- RoundRobin：轮询。按照公约后的权重设置轮询比例
- LeastActive：最少活跃数。处理较慢的节点将会受到更少的请求
- ConsistentHash：一致性哈希。相同的参数总是发送到同一个服务提供者

#### 服务治理相关配置的位置及优先级

配置在@Service和@Reference上，优先级：客户端方法级 -> 客户端接口级 -> 服务端方法级 -> 服务端接口级

#### ZooKeeper的理解

简单地说，ZooKeeper是一种有文档式结构数据存储的分布式协调中间件，通过文档是结构的特点和zk提供的节点的特点以及Watcher机制，可以实现一些分布式场景中的需求，如数据配置中心、分布式锁、Master选举、服务上下线动态感知等

#### ZooKeeper的节点类型

- 持久化节点
- 临时节点：与创建该节点的客户端生命周期一致
- 有序节点：在创建的节点后会增加一个递增的序列，持久化节点和临时节点都可以设置为有序节点
- 容器节点：当容器节点下的最后一个子节点被删除时，容器节点就会被自动删除
- TTL节点：针对持久化节点或持久化有序节点，可以设置一个存活时间，如果在存活时间内没有任何修改也没有任何子节点，他就会被自动删除

#### 服务限流的作用

限流的主要目的是通过限制并发访问数或者一个时间窗口内允许处理的请求数量来保护系统，一旦达到限制数量则对当前请求进行处理采取对应的拒绝策略，比如跳转到错误页面拒绝请求、进入排队系统、降级等。从本质上来说，限流的主要作用是损失一部分用户的可用性，为大部分用户提供稳定可靠的服务。

#### 限流常用算法

- 计数器算法：是一种比较简单的限流实现算法，在指定周期内累加访问次数，当访问次数达到设定的阈值，触发限流策略，当进入下一个时间周期时进行访问次数的清零，但是会存在临界问题，比如阈值为100，前一个时间窗口的后几秒请求为100，后一个时间窗口的前几秒请求数为100，整体看来就会有几秒内的总请求量达到200，超过了阈值
- 滑动窗口算法：为了解决计数器算法带来的临界问题，引入了滑动窗口算法。滑动窗口算法的原理是在一固定窗口中分割出多个小时间窗口，分别在每个小时间窗口中记录访问次数 ，然后根据时间将窗口往前滑动并删除过期的小时间窗口。最终只需要统计滑动窗口范围内的所有小时间窗口总的计数即可。
- 令牌桶限流算法：对于每一个请求，都需要从令牌桶中获得一个令牌，如果没有获得令牌，则需要出发限流策略。系统会以一个恒定的速度往固定容量的令牌桶中放入令牌，如果有客户端请求，则需要先从了令牌桶中拿到令牌以获得访问资格。
- 漏桶限流算法：漏桶限流算法内维护一个容器，这个容器会以恒定的速度出水，不管水桶的注水速度有多快，漏桶出水的速度适中保持不变。消息中间件就使用了漏桶限流的思想。

#### Sentinel的限流有几种方式

- QPS(Queries Per Second)
- 并发线程模式

#### Sentinel的熔断策略有几种

- 秒级RT(Response Time)
- 秒级异常比例
- 分钟级异常数

