#### 进程

进程是计算机的程序关于某一数据集合上的一次活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础

#### 线程

线程是操作系统能够进行运算调度的最小单位

#### 进程和线程的区别

- 进程是运行中的程序，线程是进程内部的一个执行序列
- 进程是资源分配的单元，线程是执行单元
- 进程间切换代价大，线程间切换代价小
- 进程拥有资源多，线程拥有资源少
- 多个线程共享进程的资源

#### 一个线程在线程池中的运行流程是什么样的

1. 新任务添加到线程池
2. 有空闲线程则立即执行
3. 可存入队列则存入队列
4. 如果没有超过最大线程数，则创建新的线程执行
5. 执行拒绝策略

#### ThreadPoolExecutor参数的含义

- corePoolSize：核心常驻线程数，即使没有任务时，也会保留的线程数
- maximumPoolSize：表示任务最多的时候可创建的最多线程数
- keepAliveTime：表示线程存活时间，当线程池空闲并超过了此时间，多余的线程就会销毁
- unit：存活时间的单位
- workQueue：线程池执行的任务队列，当线程池所有线程都在处理任务时，新进的任务就会进入该队列等待执行
- threadFactory：线程的创建工厂，较少使用
- rejectedExecutionHandler：指定线程池的拒绝策略，指定当线程池的队列满了之后，采用何种方式拒绝新的任务请求

#### 线程池execute和submit的区别

execute没有返回值，submit可以接收返回值

#### 线程池的拒绝策略

- AbortPolicy：终止策略，线程池会抛出异常并终止执行，这是默认的策略
- CallerRunsPolicy：把任务交给当前线程来执行
- DiscardPolicy：忽略此任务
- DiscardOldestPolicy：忽略最早的任务

#### SpringBean的初始化流程

- 实例化Bean
- 设置属性注入依赖
- 处理Aware相关操作
- 如果实现了InitialiizingBean则执行afterPropertiesSet方法
- BeanPostProcessor前置处理
- 执行init-method
- BeanPostProcessor后置处理

#### Spring初始化流程

主要流程在AbstractApplicationContext的refresh方法里实现

1. 为Context刷新做一些如处理
2. 刷新内部BeanFactory，创建IoC容器，通过配置解析出BeanDefinition
3. 对IoC容器做一些预处理
4. 允许子类对BeanFactory后置处理，这是一个钩子方法，由子类实现
5. 执行BeanFactory后置处理
6. 注册BeanPostProcessor后置处理器
7. 初始化一些消息资源
8. 初始化应用广播事件
9. 有一个onRefresh的钩子方法，用于初始化一些特殊的Bean，比如初始化Web容器
10. 注册一些监听器
11. 实例化Bean
12. 完成刷新

#### 反射

反射是Java提供的一种基础功能，赋予程序在运行时自省的能力。通过反射可以直接操作类或对象，如获取某个对象的类定义，获取类声明的方法和属性，执行方法或构造对象，甚至可以在运行时修改类定义

#### 接口和抽象类的区别

- 接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口不可实例化，不能含有任何非静态成员，任何属性都隐含public static final意义，没有任何非静态方法实现
- 抽象类是不可实例化的类，用abstract关键字修饰class，其主要目的是代码重用。

#### 原始数据类型和包装数据类型的区别

- 包装类型是对象，原始数据类型不是
- 作为参数的传递不一样，包装类型是引用传递，基本类型是值传递
- 声明方式不一样，包装类型需要通过new，基本数据类型不用
- 初始值不一样，包装类型初始值为null，基本类型为0、false或/u0000

#### 索引的作用和优缺点

作用：创建索引能够提高系统性能

优点：

- 通过创建唯一索引，可以保证数据表中每一行数据的唯一性
- 加快数据的检索速度
- 加快表与表之间的连接
- 在使用分组和排序，子句进行数据检索时，可以显著减少查询中分组和排序的时间
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统性能

缺点：

- 创建和维护索引需要时间
- 索引需要占用物理空间
- 数据插入、更新和删除时，索引也要动态维护，会需要时间

#### MyBatis #{} 和#{}的区别

${}是直接字符串替换

#{}是prepareStatement、字符串的两边会加上''

#### Spring事务

Spring本身并不实现事务，他只是管理事务，事务的实现还是有数据库来进行，Spring管理事务的方式有两种：编程式事务和声明式事务

#### 缓存穿透

指查询一个根本不存在的数据，缓存层和存储层都不会命中。缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。

优化方式有：

- 缓存空对象
- 布隆过滤器拦截

#### 缓存雪崩

 缓存雪崩，是指在某一个时间段，缓存集中过期失效。另外，当缓存层不能正常提供服务，所有的请求都会达到存储层，存储层的访问会暴增，很大概率会造成存储层级联宕机的情况。

预防方式有：

- 对于缓存集中过期，可以为缓存的数据做分类，缓存不同的周期，或者在设置过期时间的时候加入一个随机因子
- 保证缓存层的高可用性
- 依赖隔离组件为后端限流并降级

#### 缓存击穿

缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

预防方式：

- 对于热点数据不设置过期时间

#### Redis的rdb和AOF的区别



#### BASE理论

BASE理论是由CAP中一致性和可用性不可兼得而衍生出来的一种新的思想，BASE理论的核心思想是牺牲一部分数据的强一致性来获得高可用性

- Basically Available（基本可用）：分布式系统出现故障时，允许损失一部分功能的可用性，保证核心功能的可用
- Soft State（柔性状态）：允许系统中的数据存在中间状态，这个状态不影响系统的可用性，也就是允许系统中不同节点的数据副本之间的同步存在延迟
- Eventually Consistent（最终一致性）：中间状态的数据在经过一段时间之后，会达到一个最终的数据一致性

#### Redis Cluster数据分区

Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0~16383整数槽内，计算公式为：slot=CRC(key)&16383。每个节点负责维护一部分槽以及槽所映射的键值数据

#### SpringCloud的理解

SpringCloud并不是一种全新的框架，它是微服务场景下各解决方案基于SpringCloud规范，通过SpringBoot进行的整合，是开发人员可以以一种开箱即用的方式来使用这些框架

#### Dubbo的理解

Dubbo是一个RPC框架，实现系统之间高性能、透明化的调用，与普通RPC框架不同的是，它还提供了服务治理功能，如服务注册、监控、路由、容错等

#### RPC

Remote Process Call，远程过程调用。它是一种通过网络调用远程服务，而不需要关注低层网络技术的思想

#### Dubbo的容错模式有几种

- failover：失败自动切换。当服务调用失败时，会切到集群中的其他机器进行重试，默认次数为2，通过retries设置重试次数。通常用与读模式，因为写模式的重试可能会造成数据重复，另外，重试会导致响应延迟
- failfast：快速失败。当服务调用失败，立即报错，也就是只发起一次请求。通常用于一些幂等的写操作，可避免在结果不确定的情况下导致数据重复插入
- failsafe：失败安全。出现异常时，直接忽略
- failback：失败后自动恢复。服务调用异常时，在后台记录这条失败的请求定时重发。适用于消息通知操作，保证这个请求一定发送成功
- forking：并行调用集群中多个服务，只要一个返回成功就返回，通过forks设置
- broadcast：广播调用所有服务提供者，任意一个失败的表示服务调用失败。通常用于通知所有服务提供者更新缓存或本地资源信息
- available：调用集群中任一可用节点，如果没有则抛出异常
- mergeable：异步调用集群中的各节点，并合并结果集，一般配合group使用

#### Dubbo的负载均衡策略

- Random：随机，可调整服务器的权重值提高随机几率
- RoundRobin：轮询。按照公约后的权重设置轮询比例
- LeastActive：最少活跃数。处理较慢的节点将会受到更少的请求
- ConsistentHash：一致性哈希。相同的参数总是发送到同一个服务提供者
- ShortestResponse：最短响应时间。过滤出响应时间最短的服务提供者，如果有多个，则根据权重进行选择

#### 服务治理相关配置的位置及优先级

配置在@Service和@Reference上，优先级：客户端方法级 -> 客户端接口级 -> 服务端方法级 -> 服务端接口级

#### ZooKeeper的理解

简单地说，ZooKeeper是一种有文档式结构数据存储的分布式协调中间件，通过文档是结构的特点和zk提供的节点的特点以及Watcher机制，可以实现一些分布式场景中的需求，如数据配置中心、分布式锁、Master选举、服务上下线动态感知等

#### ZooKeeper的节点类型

- 持久化节点
- 临时节点：与创建该节点的客户端生命周期一致
- 有序节点：在创建的节点后会增加一个递增的序列，持久化节点和临时节点都可以设置为有序节点
- 容器节点：当容器节点下的最后一个子节点被删除时，容器节点就会被自动删除
- TTL节点：针对持久化节点或持久化有序节点，可以设置一个存活时间，如果在存活时间内没有任何修改也没有任何子节点，他就会被自动删除

#### 服务限流的作用

限流的主要目的是通过限制并发访问数或者一个时间窗口内允许处理的请求数量来保护系统，一旦达到限制数量则对当前请求进行处理采取对应的拒绝策略，比如跳转到错误页面拒绝请求、进入排队系统、降级等。从本质上来说，限流的主要作用是损失一部分用户的可用性，为大部分用户提供稳定可靠的服务。

#### 限流常用算法

- 计数器算法：是一种比较简单的限流实现算法，在指定周期内累加访问次数，当访问次数达到设定的阈值，触发限流策略，当进入下一个时间周期时进行访问次数的清零，但是会存在临界问题，比如阈值为100，前一个时间窗口的后几秒请求为100，后一个时间窗口的前几秒请求数为100，整体看来就会有几秒内的总请求量达到200，超过了阈值
- 滑动窗口算法：为了解决计数器算法带来的临界问题，引入了滑动窗口算法。滑动窗口算法的原理是在一固定窗口中分割出多个小时间窗口，分别在每个小时间窗口中记录访问次数 ，然后根据时间将窗口往前滑动并删除过期的小时间窗口。最终只需要统计滑动窗口范围内的所有小时间窗口总的计数即可。
- 令牌桶限流算法：对于每一个请求，都需要从令牌桶中获得一个令牌，如果没有获得令牌，则需要出发限流策略。系统会以一个恒定的速度往固定容量的令牌桶中放入令牌，如果有客户端请求，则需要先从了令牌桶中拿到令牌以获得访问资格。
- 漏桶限流算法：漏桶限流算法内维护一个容器，这个容器会以恒定的速度出水，不管水桶的注水速度有多快，漏桶出水的速度适中保持不变。消息中间件就使用了漏桶限流的思想。

#### Sentinel的限流有几种方式

- QPS(Queries Per Second)
- 并发线程模式

#### Sentinel的熔断策略有几种

- 秒级RT(Response Time)
- 秒级异常比例
- 分钟级异常数

