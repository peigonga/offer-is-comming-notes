## JVM

### 1.1 JVM的运行机制

#### Java程序执行过程
- Java源文件被编译器编译成字节码文件(.class)
- JVM通过解释器(每种操作系统的解释器是不同的)将字节码文件编译成相应操作系统的机器码
- 机器码调用相应的操作系统的本地方法库执行响应的方法


JVM虚拟机包括一个类加载器子系统、运行时数据区、执行引擎和本地接口库,
其中：
- 类加载器子系统用与将编译好的.class文件加载到JVM
- 运行时数据区用于存储在JVM运行过程中产生的数据，包括程序计数器、
  方法区、本地方法区、虚拟机栈和虚拟机堆
- 执行引擎包括即时编译器和垃圾回收器，即时编译器用于将Java字节码编译成具体的
  机器码，垃圾回收器用于在回收在运行过程中不再使用的对象
- 本地接口库用于调用操作系统的本地方法库完成具体的指令操作

#### 1.2 多线程
JVM中的线程与操作系统中的线程是相互对应的，在JVM线程的本地存储、缓冲区分配、
同步对象、栈、程序计数器等准备工作都完成时，JVM会调用操作系统的接口创建一个
与之对应原生线程；在JVM运行结束时，原生线程随之被回收。

在JVM后台运行的线程主要有：
- 虚拟机线程(JVM Thread):主要在JVM到达安全点时出现
- 周期性任务线程:通过定时器调度线程来实现周期性任务的执行
- GC线程:GC线程支持JVM中不同的垃圾回收活动
- 编译器线程:在运行时将字节码动态地编译成本地平台机器码，是JVM跨平台的具体实现
- 信号分发线程:接收发送到JVM的信号并调用JVM方法

#### 1.3 JVM的内存区域
JVM的内存区域分为线程私有区域(程序计数器、虚拟机栈、本地方法区)、线程共享
区域(堆、方法区)和直接内存。
- 线程私有区域的生命周期与线程相同，因线程与操作系统本地线程对应，所以私有内存区域
的存在与否与本地线程的生命周期对应。
- 线程共享区的生命周期与虚拟机的生命周期相同
- 直接内存也叫对外内存，他不是JVM运行时数据区的一部分，但是在并发编程中
  被频繁使用，如NIO提供的基于Channel与Buffer的IO操作、Netty、Flink、HBase、Hadoop等
<br>  
- 程序计数器：线程私有，无内存溢出问题。很小的一块内存空间，用于存储当前运行线程
  所执行的字节码的行号指示器
- 虚拟机栈：线程私有，描述Java发昂发的执行过程。是描述Java方法的执行过程的内存模型
- 本地方法区：线程私有。作用和虚拟机栈类似，虚拟机栈为执行Java方法服务，
  本地方法区为Native方法服务
- 堆：也叫运行时数据区，线程共享。在JVM运行过程中创建的对象和生产的
  数据都放在堆中
- 方法区：线程共享。也被称为永久代，用于存储敞亮、静态变量、类信息

#### 1.4 JVM的运行时内存
也叫做JVM堆，从GC的角度可以分为新生代、老生代、永久代。<br>
新生代又分为Eden区、SurvivorTo区和SurvivorFrom区
- Eden区：Java新创建的对象首先会被放在Eden区，如果创建的对象属于大对象，则直接
  将其分配到老生代
- SurvivorTo区：保留上一次MinorGC的幸存者
- SurvivorFrom区：奖上一次MinorGC的幸存者作为这一次的MinorGC的被扫描着

##### 新生代的GC过程叫MinorGC，采用复制算法实现
- 把在Eden区和SurvivorFrom区中存活对象复制到SurvivorTo区。如果某对象的年龄
  达到老年代的标准(XX:MaxTenuringThreshold，默认15)，则将其复制到老年代，
  同时对象的年龄甲乙；如果SurvivorTo区内存空间不够，也直接复制到老年代，如果对象
  为大对象(XX:PretenureSizeThreshold)也复制到老年代
- 清空Eden区和SurvivorFrom区
- 将SurvivorTo区和SurvivorFrom区互换，原来的SurvivorTo区成为下次GC的SurvivorFrom区
<br>
老年代主要存放长生命周期的对象和大对象，GC过程叫做MajorGC，使用标记清除算法，
不会被经常触发<br>
永久代只内存永久保存的区域，主要存放Class和Meta的信息。在Java8中永久代被元数据区取代，
作用类似，区别在于元数据区没有使用虚拟机内存，而是直接使用本地内存

#### 1.5 垃圾回收与算法
- 如何确定垃圾：采用引用计数法和可达性分析来确定对象是否应被回收
- 常用的垃圾回收算法：标记清除、复制、标记整理和分代收集

#### 1.6 四种引用类型
- 强引用：最常见的引用，再把一个对象赋给一个引用变量时，这个引用变量就是一个强引用。
  强引用的对象一定为可达状态，所以不会被回收
- 软引用：通过SoftReference类实现。如果一个对象只有软引用，则在系统内存空间不
  足时被回收
- 弱引用：通过WeakReference实现，如果一个对象只有弱引用，则在垃圾回收中一定会被
  回收
- 虚引用：通过PhantomReference实现，虚引用和引用队列联合使用，主要用来
  跟踪对象的垃圾回收状态

#### 1.9 Java网络编程模型
- 阻塞I/O：在读写数据时，客户端会发生阻塞。工作流程为在用户线程发出I/O请求后，
  内核会检查数据是否就绪，此时用户线程一直阻塞等待内存数据就绪，内存数据就绪后
  ，内核将数据复制到用户线程中，并返回执行结果到用户线程，此时用户线程将解除阻
  塞并开始处理数据
- 非阻塞I/O模型：指用户线程在发起一个I/O操作后，无需阻塞便可以马上得到内核
  返回的一个结果，如果内核返回的结果为false，则表室内和数据还没准备好，需要稍
  后再发起I/O操作
- 多路复用I/O模型：并发编程用的比较多的模型，Java的NIO就是基于多路复用实现的。
  一个Selector管理多个socket，节约系统资源。非阻塞I/O模型是在用户线程中
  进行Socket状态检查，多路复用I/O模型是在内核中进行Socket状态检查
- 信号驱动型I/O：在用户线程发起一个I/O请求后，系统为该请求对应的Socket
  注册一个信号函数，然后用户线程继续执行其他业务逻辑；内核数据就绪后，系统
  会发送一个信号到用户线程，然后用户线程会在信号函数中调用对应的I/O操作
- 异步I/O模型：用户线程发起一个请求到内核，内核在收到请求立即返回一个状态
  表明请求是否成功，内核在数据准备完成后将数据复制到用户线程，复制完成后发
  送一个信号到用户线程，用户线程直接使用数据
- Java I/O
- Java NIO：三大核内容：Selector、Channel、Buffer
  - Channel：核I/O中的Stream相似，Stream是单向的，Channel是双向的
  - Buffer：实际上是一个容器，其内部通过一个连续的字节数组存储I/O上的数据。
    在NIO中，Channel在文件、网络上对数据读写操作都必须经过Buffer
  - Selector：用于检测多个注册的Channel上是否有I/O事件发生，并进行相应
    的响应和处理
  
#### 1.10 JVM的类加载机制
5各阶段：加载、验证、准备、解析、初始化。
- 加载：指JVM读取Class文件，并且根据class文件描述创建java.lang.Class对象的过程。
  类加载过程主要包含将Class文件读取到运行时区域的方法区内，在堆中创建java.lang.Class
  对象，并封装类在方法取得数据结构的过程
- 验证：主要确保class文件符合当前虚拟机的要求，保障虚拟机自身安全
- 准备：主要工作是在方法区中为类变量分配内存空间并设置类中变量的初始值，
  即不同数据类型的默认值
- 解析：JVM会将常量池中的符号引用替换为直接引用
- 初始化：主要通过执行类构造器的<client>方法为类进行初始化。<clien>方法
  是编译阶段由编译器自动收集类中静态语句块和变量赋值操作组成的。父类先执行，
  子类后执行。以下几种情况JVM不会执行类的初始化流程：
  - 常量在编译时会将其常量值存入使用该常量的类的常量池中，该过程不需要
    调用常量所在的类，因此不会触发该常亮类的初始化
  - 在子类引用父类的静态字段时，不会触发子类的初始化，只会触发父类的初始化
  - 定义对象数组，不会触发该类的初始化
  - 在使用类名获取Class对象时不会触发类的初始化
  - 在使用Class.forName加载指定的类时，可以通过initialize参数设置
    是否需要对类进行初始化
  - 在使用ClassLoader默认的loadClass方法加载类时不会触发该类的初始化


##### JVM提供了三种类加载器：启动类加载器、扩展类加载器和应用程序类加载器
- 启动类加载器：负责加载Java_HOME/lib 目录中的类库，或通过
  -Xbootclasspath指定路径中被虚拟机认可的类库
- 扩展类加载器：负责加载Java_HOME/lib/ext目录中的类库，或通过
  java.ext.dirs系统变量加载指定路径中的类库
- 应用程序类加载器：负责加载用户路径(classpath)上的类库

##### JVM通过双亲委派机制对类进行加载。
双亲委派机制指一个类在收到类加载请求后，不会尝试自己加载这个类，
而是把该类家在请求向上委派给其父类去完成，其父类在接收到该类加载请求后
又会将其委派给自己的父类，以此类推，这样所有的类加载请求都被向上委派到
启动类加载器中。若父类加载器在接收到类加载请求后发现自己也无法加载该类(
通常原因是该类的Class文件在父类的类加载器路径中不存在)，则父类会将
该信息反馈给子类并向下委派类加载器，直到该类被加载成功，否则ClassNotFound